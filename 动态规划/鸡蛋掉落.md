题源：https://leetcode-cn.com/problems/super-egg-drop/

问题是这样的：N个楼层，K个鸡蛋，求最少丢T次，才能保证当F无论是[0,N]的哪个值都能被测试出。

最初的想法比较单纯，没有考虑鸡蛋数，就是二分。比如n = 5时，f可能是[0,1,2,3,4,5]，那我就从中间楼层，即第三层丢下鸡蛋，如果碎了那说明f在[0,1,2]，没碎那说明f在[3,4,5]，一直细分，直到只有两层楼的时候，此时只需要再丢一次就能得出结果。在鸡蛋数无限的情况下，这种方法是完全正确的。然而鸡蛋数是有限。

设想这样一种极端的情况，当鸡蛋只有1个的时候，而n = 5，那我们还能从第三层丢下鸡蛋吗？如果不碎的话还能继续排除，但是如果鸡蛋碎了的话，说明f在[0,1,2]楼，**但是我们已经没有鸡蛋可以测试了**。所以直接二分肯定是不行的。

这时候我开始考虑动态规划，dp[k]\[n]表示k个鸡蛋，在一栋n层的楼测出f的最小操作次数。终于我想出了递推式，首先dp[1]\[n] = n，因为当只有一个鸡蛋的时候，你只能从第0层开始丢。当有多个鸡蛋时，之前说过，鸡蛋数充足的话从中间楼层丢鸡蛋是完全正确的，但是鸡蛋数不足的话，从中间楼层丢下就不行了，那这时要从哪层楼丢下鸡蛋呢？我也不知道，所以直接暴力遍历：

对于dp[i]\[j]，我们试试从第x楼丢下鸡蛋（$1<=x<=j$）。如果鸡蛋碎了，还需要测试的次数为dp[i - 1]\[x - 1]，表示鸡蛋少一个，而且f只可能在x的楼下；如果鸡蛋没碎，则还需要测试的次数为dp[i]\[j - x]，表示鸡蛋不少，而且f只可能在x的楼上。总结：在第x楼丢鸡蛋，我们需要测试的次数为1 + **max**(dp[i - 1]\[x - 1], dp[i]\[j - x])。对于所有可能的x，我们取它们的**最小值**。该算法的时间复杂度为$O(kn^2)$，这肯定会超时的。

那如何优化呢？在上述的方法中，对于第一次丢鸡蛋要从哪层楼丢，我们是用暴力遍历的方法来进行的，这里是$O(n)$的时间复杂度，对于这部分，我们可以用二分法来找。理由如下：

“在第x楼丢鸡蛋，我们需要测试的次数为1 + **max**(dp[i - 1]\[x - 1], dp[i]\[j - x])。对于所有可能的x，我们取它们的**最小值**”。对于dp[i -1]\[x - 1]来说，毫无疑问，它是关于x的单调递增函数，而对于dp[i]\[j - x]来说，它是关于x的单调递减函数。如果这两个函数是连续的，如下图所示：

![image1](images\鸡蛋掉落1.png)

**max(dp[i - 1]\[x - 1], dp[i]\[j - x])的最小值，就是两个函数的相交之处！**但是这两个函数是离散的函数，但是也不影响，我们需要找到的就是离的最近的那两个点，如下图所示：

![image2](.\images\鸡蛋掉落2.png)

最小值就在这两个点中产生。

代码如下：

```c++
class Solution {
public:
    unordered_map<int, int> memo;
    int dp(int k, int n) {
        if (memo.find(n * 100 + k) == memo.end()) {
            int ans;
            if (n == 0) {
                ans = 0;
            } else if (k == 1) {
                ans = n;
            } else {
                int lo = 1, hi = n;
                while (lo + 1 < hi) {
                    int x = (lo + hi) / 2;
                    int t1 = dp(k - 1, x - 1);
                    int t2 = dp(k, n - x);

                    if (t1 < t2) {
                        lo = x;
                    } else if (t1 > t2) {
                        hi = x;
                    } else {
                        lo = hi = x;
                    }
                }

                ans = 1 + min(max(dp(k - 1, lo - 1), dp(k, n - lo)),
                                   max(dp(k - 1, hi - 1), dp(k, n - hi)));
            }
            memo[n * 100 + k] = ans;
        }

        return memo[n * 100 + k];
    }

    int superEggDrop(int k, int n) {
        return dp(k, n);
    }
};
```

还有一种很巧妙的思路，我们原先的问题是：N个楼层，有K个鸡蛋，求最少丢T次，才能保证当F无论是[0,N]的哪个值都能被测试出来。我们可以将其转换成这样的问题：有K个鸡蛋，我丢T次，求可以确定的最高楼层。T从一慢慢递增，当我丢T次，就可以确认N个楼层时，此时的T就是要求的解。

出口：当K = 1或者T = 1时，即只有一个鸡蛋或者只有一次丢鸡蛋的机会时（其实是一样的），我能确定的最高楼层是一。因为我只能丢一次，所以我直接在第一层丢，如果碎了那说明最高层是0层，如果没碎，那说明最高层至少是1层。

如果我有多个鸡蛋或者多次机会时，那我能确定的楼层数就是（蛋碎了一个，机会减一次）+（蛋碎了一个，机会减一次）。时间复杂度为$O(kn^2)$，代码如下：

```c++
class Solution {
public:
    int calcF(int K, int T)
    {
        if (T == 1 || K == 1) return T + 1;
        return calcF(K - 1, T - 1) + calcF(K, T - 1);
    }

    int superEggDrop(int K, int N)
    {
        int T = 1;
        while (calcF(K, T) < N + 1) T++;
        return T;
    }
};
```

时间复杂度有点高，是因为calcF(K - 1, T - 1) + calcF(K, T - 1)其实多计算了好多次，可以增加额外空间存一下之前的值。但是问题转变之后，思路就变得清晰很多了。
