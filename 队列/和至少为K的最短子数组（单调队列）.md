题源：https://leetcode-cn.com/problems/shortest-subarray-with-sum-at-least-k/

原来想的是滑动窗口，但是由于数组是带有负数的，所以前缀和数组也会变得无序，这时滑动窗口的边界很难移动，所以放弃。

本题使用前缀和+单调双向队列来做，为什么要用单调队列呢，其实就相当于人为地让前缀和保持在一个有序的状态，但如果只是这样的话，只能解决“子数组和大于等于K”这个问题，但本题需要求出和大于等于K的子数组中，最短的那个的长度。所以在保证队列单调的情况下，还需要进行“筛选”。

这里队列需要是单调升序的，而且因为需要求子数组长度，所以队列中存放的是前缀和数组的下标。

首先求得前缀和数组sums，遍历之，对于此时的sums[i]:

- while 队不空 && sum[i] <= sum[队尾] 
  - 队尾出队。
- while队不空 && sum[i] - sum[队头] >= K
  - 尝试更新最小长度
  - 队首出队
- i入队尾

第一步：为什么sum[i] <= sum[队尾]时，队尾要出队。对于序列[1,4-2,4]，其前缀和为[1,5,3,7]，当队中存放[1,5]时，我们已经得到了此时的最佳结果（无论有没有最佳结果），当遇到3时，对于7-3来说，无论是差值还是长度，都要优于7-5，所以5完全可以被放弃。更重要的是，如果前缀和是[5,3,7]的话，当遇到3时，3才更有可能诞生符合条件的子数组，为了维护更好的升序队列，必须放弃5留下3。

第二步：sum[队头]是最小值，如果sum[i]-sum[队头]能满足条件，那有可能会有更小的子数组，比如序列[1,2,50]，前缀和为[1,3,53]，K=20，当53-1大于K时，其实53-3也大于K，所以需要继续判断，此时1和3已经没有用了，因为以1和3为队首的最优解已经找到了，所以让他们出队。

这里还有一个小技巧，前缀和的size需要+1，比如[2,-1,2]，前缀和是[2,1,3]，K=3，由于前缀和刚好满足3，所以减0才行，所以最前面要加个0方便操作。

时间复杂度和空间复杂度都为$O(N)$，代码如下：

```c++
class Solution {
public:
    int shortestSubarray(vector<int>& nums, int k) {
        int size = nums.size();
        vector<double> sums(size + 1); //前缀和，长度+1，方便操作
        for(int i = 1; i < size + 1; i++) sums[i] = sums[i - 1] + nums[i - 1];
        int res = INT_MAX;
        deque<int> q; //单调升序队列，存放前缀和数组的下标
        for(int i = 0; i < size + 1; i++) {
            while(!q.empty() && sums[i] <= sums[q.back()]) q.pop_back();
            while(!q.empty() && sums[i] - sums[q.front()] >= k) {
                if(i - q.front() < res) res = i - q.front();
                q.pop_front();
            }
            q.push_back(i);
        }
        if(res == INT_MAX) return -1;
        return res;
    }
};
```

对于这类单调栈或单调队列，关键是如何维护其单调属性才能满足题目要求。